
## Ch.1


| 1-1.js | 변수 `a` 선언 |


| 1-2.js | 변수 `a` 선언 및 데이터 할당 |


| 1-3.js | 불변하는 기본형 데이터 예시 |


| 1-4.js | 참조형 데이터(object)를 변수에 할당하는 예 |


| 1-5.js | 참조형 데이터의 프로퍼티를 재할당하는 방법 |


| 1-6.js | 객체 내부의 프로퍼티에 객체를 할당 |


| 1-7.js | 기본형과 참조형 데이터의 변수 복사 비교 |


| 1-8.js | 객체의 프로퍼티 변경 시 → 가변 객체 동작 |


| 1-9.js | 객체 자체를 새로 할당 시 → 불변 객체 동작 |


| 1-10.js | 같은 object를 참조하는 두 변수 (`user`, `user2`) |


| 1-11.js | 새 객체를 생성하여 주소를 다르게 하는 방법 |


| 1-12.js | 기존 정보를 복사해 shallow copy 수행 |


| 1-13.js | `copyObject()` 함수를 통한 복사 방식 |


| 1-14.js | shallow copy 시 원본 object가 변하는 문제점 |


| 1-15.js | 깊은 복사 방식 (원본 변경 없이 복사) |


| 1-16.js | `copyObjectDeep()` 함수로 깊은 복사 수행 |


| 1-17.js | 깊은 복사의 결과 확인 |


| 1-18.js | `JSON.stringify` / `parse` 를 통한 깊은 복사 |


| 1-19.js | return이 없을 경우 자동으로 `undefined` 반환됨 |


| 1-20.js | `undefined`와 `empty`의 헷갈리는 차이점 |


| 1-21.js | `empty` 배열과 변수 비교 |


| 1-22.js | `undefined` vs `null` 비교 |



---

## Ch.2


| 2-1.js | Hoisting 개념과 실행 순서 |


| 2-2.js | 함수와 변수 선언 시 출력값 예측 |


| 2-3.js | 내부 선언된 변수의 호이스팅 예 |


| 2-4.js | 호이스팅 시 변수명만 끌어올려짐 |


| 2-5.js | 변수 두 번 선언 시 처리 방식 |


| 2-6.js | 함수 선언문 해석 방식 |


| 2-7.js | 함수 선언문 → 함수 표현식으로 변경 |


| 2-8.js | 함수 선언 방식 3가지 비교 |


| 2-9.js | 호이스팅 이후 코드 실행 흐름 |


| 2-10.js | 호이스팅 이후의 최종 상태 |


| 2-11.js | 함수 선언문이 문제를 일으키는 경우 |


| 2-12.js | 함수 표현식은 호이스팅 후에도 안전함 |


| 2-13.js | 스코프 체인 실습 |



---

## Ch.3


| 3-1.js | 브라우저 환경에서의 this |


| 3-2.js | Node.js 환경에서의 this |


| 3-3.js | 전역 공간의 this는 전역 객체 |


| 3-4.js | 전역 변수 선언과 전역 객체 속성 연결 |


| 3-5.js | 전역 변수는 delete로 삭제되지 않음 |


| 3-6.js | 메서드로 호출될 때만 this가 객체를 가리킴 |


| 3-7.js | 함수 앞에 객체가 있을 때 this는 그 객체 |


| 3-8.js | 점 앞의 객체가 this가 되는 구조 |


| 3-9.js | 함수마다 서로 다른 this가 존재함 |


| 3-10.js | 중첩 함수에서의 this는 기본적으로 전역 |


| 3-11.js | 화살표 함수는 상위 스코프의 this를 사용 |


| 3-12.js | 콜백 함수는 인자로 전달되어 실행되는 함수 |


| 3-13.js | `new`를 사용해 생성자 함수 호출 (인스턴스 생성) |


| 3-14.js | `call()`을 사용해 임의 객체를 this로 지정 |


| 3-15.js | call 메서드에서 객체 내 메서드 호출 시 this 유지 |


| 3-16.js | `apply()`는 두 번째 인자에 배열을 넘겨줌 |


| 3-17.js | array-like 객체의 특징 (index와 length 존재) |


| 3-18.js | arguments, NodeList도 array-like 객체 |


| 3-19.js | 문자열도 array-like, `map()`은 새 배열 반환 |


| 3-20.js | `Array.from()`은 array-like를 배열로 변환 가능 |


| 3-21.js | 생성자 함수에서 다른 생성자를 호출하는 패턴 |


| 3-22.js | apply를 안 쓸 경우 코드가 길어지는 문제 |


| 3-23.js | `Math.max.apply`로 인자 배열 넘기기 |


| 3-24.js | ES6의 spread 연산자로 간결하게 구현 |


| 3-25.js | `bind()` 함수로 this를 고정하는 방법 |


| 3-26.js | `bind()`를 사용하면 함수 이름이 `"bound "`로 시작함 |


| 3-27.js | 내부 함수에 `bind(this)`나 `call(this)` 적용 |


| 3-28.js | `setTimeout()`은 기본적으로 this를 잃어버림 → bind 필요 |


| 3-29.js | 화살표 함수는 선언된 위치의 this를 참조 |


| 3-30.js | `forEach()`에서 콜백에서도 안전하게 this 넘기는 예 |


| 3-31.js | `thisArg`를 콜백 메서드 두 번째 인자로 전달 가능 |



---

## Ch.4


| 4-1.js  | `setInterval`로 일정 시간마다 count를 출력하고 종료 조건 처리 |


| 4-2.js  | 콜백 함수를 분리하여 `setInterval`에 전달하여 제어권 가짐 |


| 4-3.js  | `map`메서드가 array의 프로토타입에 담긴 경우 |


| 4-4.js  | `map` 콜백의 인자 순서를 임의로 바꿔 결과 출력 |


| 4-5.js  | `Array.prototype.map`을 직접 구현하여 동작 원리를 확인 |


| 4-6.js  | `this`가 일반 함수, 콜백, 이벤트 리스너에서 다르게 바인딩됨 |


| 4-7.js  | 메서드를 콜백으로 전달할 때 함수로서 호출됨 |


| 4-8.js  | `this`를 유지하기 위해 `self`에 저장한 후 사용하는 방법 |


| 4-9.js  | 콜백 함수 안에서 this를 사용하지 않을 경우 |


| 4-10.js | 메서드를 다른 객체나 함수로 전달할 때 this가 바뀜 |


| 4-11.js | `bind`를 이용해 `this`를 특정 객체로 고정하여 실행 |


| 4-12.js | 중첩된 `setTimeout`을 이용 |


| 4-13.js | 콜백 함수를 분리하여 가독성 문제 해결 |


| 4-14.js | `Promise` 체인을 이용해 비동기 작업 실시 |


| 4-15.js | `Promise`와 커링을 활용한 간결한 비동기 작업 실시 |


| 4-16.js | Generator 함수와 `yield`를 활용한 비동기 작업 실시시 |


| 4-17.js | `async/await`를 사용하여 가독성 높은 비동기 코드 구성         |



---

## Ch.5


| 5-1.js  | 내부 함수가 외부 변수에 접근하는 클로저 구조 |


| 5-2.js  | 클로저를 통해 내부 함수가 실행된 값을 return |


| 5-3.js  | 내부 함수를 return하여 클로저로 상태를 유지함 |


| 5-4.js  | 클로저가 `setInterval`, `eventListener`에서 변수 값을 기억 |


| 5-5.js  | 클로저의 참조를 제거해 메모리를 해제 |


| 5-6.js  | 콜백 함수 중 하나인 이벤트 리스너 활용함 |


| 5-7.js  | 콜백 함수를 공통 함수로 사용하는 경우 |


| 5-8.js  | `bind(null, fruit)`로 예제 5-7 보완 |


| 5-9.js  | 콜백 함수를 고차함수로 바꾸는 방식으로 클로저 이용 |


| 5-10.js | 객체 내부에서 상태값을 갖고 메서드로 동작하는 자동차 |


| 5-11.js | 클로저로 외부에서의 접근 제한 |


| 5-12.js | `Object.freeze()`를 사용하여 외부 변경 방지 |


| 5-13.js | `bind()`를 사용해 함수 일부 인자를 고정한 부분 적용 함수 |


| 5-14.js | this에 영향 주지 않고 `partial()` 사용하는 방법 |


| 5-15.js | `_` 자리 지정 후 나중에 인자를 채우는 방법 |


| 5-16.js | debounce 함수로 이벤트 실행을 지연시켜 제어 |


| 5-17.js | 커링 함수 활용 방법 |


| 5-18.js | 다중 커링 함수로 여러 인자를 순차적으로 적용하면 가독성이 떨어지는 문제 발생 |



---

## Ch.6


| 6-1.js | 생성자 함수에 메서드를 prototype으로 정의 |


| 6-2.js | 생성자와 인스턴스의 prototype 구조 확인 |


| 6-3.js | 배열의 constructor 속성과 new 사용 예 |


| 6-4.js | constructor 속성을 재정의해도 instanceof는 false |


| 6-5.js | 다양한 방식으로 constructor를 통해 객체 생성 |


| 6-6.js | 인스턴스에서 prototype 메서드 오버라이드 |


| 6-7.js | 배열에 값 추가 시 인덱스가 ownProperty인지 확인 |


| 6-8.js | toString 메서드를 오버라이드해 출력 방식 변경 |


| 6-9.js | 객체에 getEntries 메서드 추가 및 자료형 비교 |


| 6-10.js | arguments를 유사 배열 형태로 저장하는 Grade 객체 |



---

## Ch.7


| 7-1.js | 인스턴스 메서드와 static 메서드의 차이 비교 |


| 7-2.js | Grade의 prototype을 배열로 설정 |


| 7-3.js | Grade 인스턴스에 push 사용 시 length 조작 실험 |


| 7-4.js | prototype 배열과 인스턴스 배열이 충돌하는 경우 |


| 7-5.js | Rectangle과 Square의 메서드를 각각 정의 |


| 7-6.js | Square에서 height를 width와 동일하게 할당 |


| 7-7.js | Rectangle을 call로 실행하고 prototype 상속 처리 |


| 7-8.js | extendClass1 함수로 프로토타입 상속 구현 |


| 7-9.js | Bridge 패턴을 사용한 프로토타입 상속 구현 |


| 7-10.js | Object.create를 이용한 상속 처리 방식 |


| 7-11.js | extendClass1에 constructor 속성 명시 |


| 7-12.js | extendClass2에서 super 호출 및 constructor 처리 |


| 7-13.js | Object.create로 간결하게 상속 구현 |


| 7-14.js | super()와 super('메서드') 호출 구현 |


| 7-15.js | ES5와 ES6 클래스의 static/인스턴스 메서드 비교 |


| 7-16.js | ES6 class 상속에서 super 키워드 사용 예제 |


