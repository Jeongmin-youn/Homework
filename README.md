
## Ch.1


| 1-1.js | 변수 `a` 선언 |


| 1-2.js | 변수 `a` 선언 및 데이터 할당 |


| 1-3.js | 불변하는 기본형 데이터 예시 |


| 1-4.js | 참조형 데이터(object)를 변수에 할당하는 예 |


| 1-5.js | 참조형 데이터의 프로퍼티를 재할당하는 방법 |


| 1-6.js | 객체 내부의 프로퍼티에 객체를 할당 |


| 1-7.js | 기본형과 참조형 데이터의 변수 복사 비교 |


| 1-8.js | 객체의 프로퍼티 변경 시 → 가변 객체 동작 |


| 1-9.js | 객체 자체를 새로 할당 시 → 불변 객체 동작 |


| 1-10.js | 같은 object를 참조하는 두 변수 (`user`, `user2`) |


| 1-11.js | 새 객체를 생성하여 주소를 다르게 하는 방법 |


| 1-12.js | 기존 정보를 복사해 shallow copy 수행 |


| 1-13.js | `copyObject()` 함수를 통한 복사 방식 |


| 1-14.js | shallow copy 시 원본 object가 변하는 문제점 |


| 1-15.js | 깊은 복사 방식 (원본 변경 없이 복사) |


| 1-16.js | `copyObjectDeep()` 함수로 깊은 복사 수행 |


| 1-17.js | 깊은 복사의 결과 확인 |


| 1-18.js | `JSON.stringify` / `parse` 를 통한 깊은 복사 |


| 1-19.js | return이 없을 경우 자동으로 `undefined` 반환됨 |


| 1-20.js | `undefined`와 `empty`의 헷갈리는 차이점 |


| 1-21.js | `empty` 배열과 변수 비교 |


| 1-22.js | `undefined` vs `null` 비교 |



---

## Ch.2


| 2-1.js | Hoisting 개념과 실행 순서 |


| 2-2.js | 함수와 변수 선언 시 출력값 예측 |


| 2-3.js | 내부 선언된 변수의 호이스팅 예 |


| 2-4.js | 호이스팅 시 변수명만 끌어올려짐 |


| 2-5.js | 변수 두 번 선언 시 처리 방식 |


| 2-6.js | 함수 선언문 해석 방식 |


| 2-7.js | 함수 선언문 → 함수 표현식으로 변경 |


| 2-8.js | 함수 선언 방식 3가지 비교 |


| 2-9.js | 호이스팅 이후 코드 실행 흐름 |


| 2-10.js | 호이스팅 이후의 최종 상태 |


| 2-11.js | 함수 선언문이 문제를 일으키는 경우 |


| 2-12.js | 함수 표현식은 호이스팅 후에도 안전함 |


| 2-13.js | 스코프 체인 실습 |



---

## Ch.3


| 3-1.js | 브라우저 환경에서의 this |


| 3-2.js | Node.js 환경에서의 this |


| 3-3.js | 전역 공간의 this는 전역 객체 |


| 3-4.js | 전역 변수 선언과 전역 객체 속성 연결 |


| 3-5.js | 전역 변수는 delete로 삭제되지 않음 |


| 3-6.js | 메서드로 호출될 때만 this가 객체를 가리킴 |


| 3-7.js | 함수 앞에 객체가 있을 때 this는 그 객체 |


| 3-8.js | 점 앞의 객체가 this가 되는 구조 |


| 3-9.js | 함수마다 서로 다른 this가 존재함 |


| 3-10.js | 중첩 함수에서의 this는 기본적으로 전역 |


| 3-11.js | 화살표 함수는 상위 스코프의 this를 사용 |


| 3-12.js | 콜백 함수는 인자로 전달되어 실행되는 함수 |


| 3-13.js | `new`를 사용해 생성자 함수 호출 (인스턴스 생성) |


| 3-14.js | `call()`을 사용해 임의 객체를 this로 지정 |


| 3-15.js | call 메서드에서 객체 내 메서드 호출 시 this 유지 |


| 3-16.js | `apply()`는 두 번째 인자에 배열을 넘겨줌 |


| 3-17.js | array-like 객체의 특징 (index와 length 존재) |


| 3-18.js | arguments, NodeList도 array-like 객체 |


| 3-19.js | 문자열도 array-like, `map()`은 새 배열 반환 |


| 3-20.js | `Array.from()`은 array-like를 배열로 변환 가능 |


| 3-21.js | 생성자 함수에서 다른 생성자를 호출하는 패턴 |


| 3-22.js | apply를 안 쓸 경우 코드가 길어지는 문제 |


| 3-23.js | `Math.max.apply`로 인자 배열 넘기기 |


| 3-24.js | ES6의 spread 연산자로 간결하게 구현 |


| 3-25.js | `bind()` 함수로 this를 고정하는 방법 |


| 3-26.js | `bind()`를 사용하면 함수 이름이 `"bound "`로 시작함 |


| 3-27.js | 내부 함수에 `bind(this)`나 `call(this)` 적용 |


| 3-28.js | `setTimeout()`은 기본적으로 this를 잃어버림 → bind 필요 |


| 3-29.js | 화살표 함수는 선언된 위치의 this를 참조 |


| 3-30.js | `forEach()`에서 콜백에서도 안전하게 this 넘기는 예 |


| 3-31.js | `thisArg`를 콜백 메서드 두 번째 인자로 전달 가능 |

